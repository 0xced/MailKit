<?xml version="1.0" encoding="utf-8"?>
<topic id="FrequentlyAskedQuestions" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <!--
    <summary>
      <para>Optional summary abstract</para>
    </summary>
    -->

    <introduction>
      <autoOutline />
    </introduction>

    <section address="CompletelyFree">
      <title>Are MimeKit and MailKit completely free? Can I use them in my proprietary product(s)?</title>
      <content>
        <para>
          Yes. MimeKit and MailKit are both completely free and open source. They are both covered under
          the <link xlink:href="https://opensource.org/licenses/MIT">MIT</link> license.
        </para>
      </content>
    </section>

    <section address="CreateAttachments">
      <title>How do I create a message with attachments?</title>
      <content>
        <para>
          To construct a message with attachments, the first thing you'll need to do is create a
          <literal>multipart/mixed</literal> container which you'll then want to add the message
          body to first. Once you've added the body, you can then add MIME parts to it that contain
          the content of the files you'd like to attach, being sure to set the
          <literal>Content-Disposition</literal> header value to <literal>attachment</literal>.
          You'll probably also want to set the <literal>filename</literal> parameter on the
          <literal>Content-Disposition</literal> header as well as the <literal>name</literal>
          parameter on the <literal>Content-Type</literal> header. The most convenient way to do this
          is to simply use the <codeEntityReference qualifyHint="true">
          P:MimeKit.MimePart.FileName</codeEntityReference> property which will set both parameters
          for you as well as setting the <literal>Content-Disposition</literal> header value to
          <literal>attachment</literal> if it has not already been set to something else.
        </para>
        <para>
          A simpler way to construct messages with attachments is to take advantage of the
          <codeEntityReference>T:MimeKit.BodyBuilder</codeEntityReference> class.
        </para>
        <code language="c#" source="Examples\BodyBuilder.cs"/>
        <para>
          For more information, see <link xlink:href="CreatingMessages">Creating Messages</link>.
        </para>
      </content>
    </section>

    <section address="MessageBody">
      <title>How do I get the main body of a message?</title>
      <content>
        <para>
          (Note: for the TL;DR version, skip to the end)
        </para>
        <para>
          MIME is a tree structure of parts. There are multiparts which contain other parts
          (even other multiparts). There are message parts which contain messages. And finally,
          there are leaf-node parts which contain content.
        </para>
        <para>
          There are a few common message structures:
        </para>
        <list class="ordered">
          <listItem address="MessageBodyExample1">
            <para>
              The message contains only a <literal>text/plain</literal> or
              <literal>text/html</literal> part (easy, just use that).
            </para>
          </listItem>
          <listItem address="MessageBodyExample2">
            <para>
              The message contains a <literal>multipart/alternative</literal>
              which will typically look a bit like this:<markup><pre>
multipart/alternative
  text/plain
  text/html</pre></markup>
            </para>
          </listItem>
          <listItem address="MessageBodyExample3">
            <para>
              Same as above, but the html part is inside a <literal>multipart/related</literal> so
              that it can embed images:<markup><pre>
multipart/alternative
  text/plain
  multipart/related
    text/html
    image/jpeg
    image/png</pre></markup>
            </para>
          </listItem>
          <listItem address="MessageBodyExample4">
            <para>
              The message contains a textual body part as well as some attachments:<markup><pre>
multipart/mixed
  text/plain
  application/octet-stream
  application/zip</pre></markup>
            </para>
          </listItem>
          <listItem address="MessageBodyExample5">
            <para>
              The same as above, but with the first part replaced with either
              <link xlink:href="FrequentlyAskedQuestions#MessageBodyExample2">#2</link> or
              <link xlink:href="FrequentlyAskedQuestions#MessageBodyExample3">#3</link>
              To illustrate:<markup><pre>
multipart/mixed
  multipart/alternative
    text/plain
    text/html
  application/octet-stream
  application/zip</pre></markup>
            </para>
            <para>
              Or:<markup><pre>
multipart/mixed
  multipart/alternative
    text/plain
    multipart/related
      text/html
      image/jpeg
      image/png
  application/octet-stream
  application/zip</pre></markup>
            </para>
          </listItem>
        </list>
        <para>
          For your convenience, the <codeEntityReference>T:MimeKit.MimeMessage</codeEntityReference>
          class has 2 properties that you may find useful:
          <codeEntityReference>P:MimeKit.MimeMessage.TextBody</codeEntityReference> and
          <codeEntityReference>P:MimeKit.MimeMessage.HtmlBody</codeEntityReference>.
        </para>
        <para>
          For more information, see <link xlink:href="WorkingWithMessages"/>.
        </para>
      </content>
    </section>

    <section address="HasAttachments">
      <title>How do I tell if a message has attachments?</title>
      <content>
        <para>
          In most cases, a message with a body that has a MIME-type of <literal>multipart/mixed</literal>
          containing more than a single part probably has attachments. As illustrated above, the first part
          of a </literal>multipart/mixed</literal> is typically the textual body of the message, but it is
          not always quite that simple.
        </para>
        <para>
          In general, MIME attachments will have a <literal>Content-Disposition</literal> header with a
          value of <literal>attachment</literal>. To get the list of body parts matching this criteria,
          you can use the <codeEntityReference qualifyHint="true">
          P:MimeKit.MimeMessage.Attachments</codeEntityReference> property.
        </para>
        <para>
          Unfortunately, not all mail clients follow this convention and so you may need to write your
          own custom logic. For example, you may wish to treat all body parts having a <literal>name</literal>
          or <literal>filename</literal> parameter set on them:
        </para>
        <code language="c#">
var attachments = message.BodyParts.OfType<MimePart> ().Where (part => !string.IsNullOrEmpty (part.FileName));
        </code>
        <para>
          A more sophisticated approach is to treat body parts not referenced by the main textual body part of
          the message as attachments. In other words, treat any body part not used for rendering the message
          as an attachment. For an example on how to do this, consider the following code snippets:
        </para>
        <code language="c#" source="Examples\MimeVisitorExamples.cs" region="HtmlPreviewVisitor"/>
        <para>And the way you'd use this visitor might look something like this:</para>
        <code language="c#" source="Examples\MimeVisitorExamples.cs" region="RenderMessage"/>
        <para>
          Once you've rnedered the message using the above technique, you'll have a list of attachments
          that were not used, even if they did not match the simplistic criteria used by the
          <codeEntityReference qualifyHint="true"> P:MimeKit.MimeMessage.Attachments</codeEntityReference>
          property.
        </para>
      </content>
    </section>

    <section address="EmailAddresses">
      <title>How do I get the email addresses in the From, To, and Cc headers?</title>
      <content>
        <para>
          The <codeEntityReference>P:MimeKit.MimeMessage.From</codeEntityReference>,
          <codeEntityReference>P:MimeKit.MimeMessage.To</codeEntityReference>, and
          <codeEntityReference>P:MimeKit.MimeMessage.Cc</codeEntityReference>
          properties of a <codeEntityReference>T:MimeKit.MimeMessage</codeEntityReference>
          are all of type <codeEntityReference>T:MimeKit.InternetAddressList</codeEntityReference>.
          An <codeEntityReference>T:MimeKit.InternetAddressList</codeEntityReference> is a list of
          <codeEntityReference>T:MimeKit.InternetAddress</codeEntityReference> items.
          This is where some people start to get lost, conceptually, because
          <codeEntityReference>T:MimeKit.InternetAddress</codeEntityReference> is an
          abstract class that only really has a
          <codeEntityReference>P:MimeKit.InternetAddress.Name</codeEntityReference>
          property.
        </para>
        <para>
          As you've probably already discovered, the
          <codeEntityReference>P:MimeKit.InternetAddress.Name</codeEntityReference>
          property contains the name of the person (if available), but what you probably
          want is his or her email address, not their name. So how do you get it?
        </para>
        <para>
          To get the email address, you'll need to figure out what subclass of address each
          <codeEntityReference>T:MimeKit.InternetAddress</codeEntityReference> really is.
          There are 2 direct subclasses of
          <codeEntityReference>T:MimeKit.InternetAddress</codeEntityReference>. They are:
          <codeEntityReference>T:MimeKit.GroupAddress</codeEntityReference> and
          <codeEntityReference>T:MimeKit.MailboxAddress</codeEntityReference>.
        </para>
        <para>
          A <codeEntityReference>T:MimeKit.GroupAddress</codeEntityReference> is a named group
          of more <codeEntityReference>T:MimeKit.InternetAddress</codeEntityReference> items that
          are contained within the
          <codeEntityReference>P:MimeKit.GroupAddress.Members</codeEntityReference> property. To
          get an idea of what a group address represents, consider the following examples:
        </para>
        <para>
          <literal>
            To: My Friends: Joey &lt;joey@friends.com&gt;, Monica &lt;monica@friends.com&gt;,
            "Mrs. Chanandler Bong" &lt;chandler@friends.com&gt;, Ross &lt;ross@friends.com&gt;,
            Rachel &lt;rachel@friends.com&gt;;
          </literal>
        </para>
        <para>
          In the above example, the <codeEntityReference>P:MimeKit.MimeMessage.To</codeEntityReference>
          header's <codeEntityReference>T:MimeKit.InternetAddressList</codeEntityReference> will
          contain only 1 item which will be a
          <codeEntityReference>T:MimeKit.GroupAddress</codeEntityReference> with a
          <codeEntityReference>P:MimeKit.InternetAddress.Name</codeEntityReference> value of
          <literal>My Friends</literal>. The
          <codeEntityReference>P:MimeKit.GroupAddress.Members</codeEntityReference> property of
          the <codeEntityReference>T:MimeKit.GroupAddress</codeEntityReference> will contain 5
          more <codeEntityReference>T:MimeKit.InternetAddress</codeEntityReference> items (which
          will all be instances of <codeEntityReference>T:MimeKit.MailboxAddress</codeEntityReference>).
        </para>
        <para>
          The above example, however, is not very likely to ever be seen in messages you deal with.
          A far more common example would be the one below:
        </para>
        <para>
          <literal>To: undisclosed-recipients:;</literal>
        </para>
        <para>
          Most of the time, the <codeEntityReference>P:MimeKit.MimeMessage.From</codeEntityReference>,
          <codeEntityReference>P:MimeKit.MimeMessage.To</codeEntityReference>, and
          <codeEntityReference>P:MimeKit.MimeMessage.Cc</codeEntityReference> headers will only
          contain mailbox addresses. As you will notice, a
          <codeEntityReference>T:MimeKit.MailboxAddress</codeEntityReference> has an
          <codeEntityReference>P:MimeKit.MailboxAddress.Address</codeEntityReference> property
          which will contain the email address of the mailbox. In the following example, the
          <codeEntityReference>P:MimeKit.MailboxAddress.Address</codeEntityReference> property
          will contain the value <literal>john@smith.com</literal>:
        </para>
        <para>
          <literal>To: John Smith &lt;john@smith.com&gt;</literal>
        </para>
        <para>
          If you only care about getting a flattened list of the mailbox addresses in one of
          the address headers, you can simply do something like this:
        </para>
        <code language="c#">
foreach (var mailbox in message.To.Mailboxes)
    Console.WriteLine ("{0}'s email address is {1}", mailbox.Name, mailbox.Address);
        </code>
      </content>
    </section>

    <section address="UnreadMessages">
      <title>How do I get all of the unread messages in a folder?</title>
      <content>
        <para>
          The easiest way is to search for all of the messages that do not have the
          <literal>\Seen</literal> flag on them, like so:
        </para>
        <code language="c#">
foreach (var uid in folder.Search (SearchQuery.NotSeen)) {
    var message = folder.GetMessage (uid);
}
        </code>
      </content>
    </section>

    <section address="Serialize">
      <title>Why doesn't the MimeMessage class implement ISerializable so that I can serialize a
      message to disk and read it back later?</title>
      <content>
        <para>
          The MimeKit API was designed to use the existing MIME format for serialization. In light
          of this, the ability to use the .NET serialization API and format did not make much sense
          to support.
        </para>
        <para>
          You can easily serialize a MimeMessage to a stream using the
          <codeEntityReference autoUpgrade="true">
          M:MimeKit.MimeMessage.WriteTo (System.IO.Stream,System.Threading.CancellationToken)
          </codeEntityReference> methods.
        </para>
      </content>
    </section>

    <section address="UntitledAttachments">
      <title>Why do attachments with unicode filenames appear as "ATT0####.dat" in Outlook?</title>
      <content>
        <para>
          An attachment filename is stored as a MIME parameter on the <literal>Content-Disposition</literal>
          header. Unfortunately, the original MIME specifications did not specify a method for encoding
          non-ascii filenames. In 1997, <link xlink:href="https://tools.ietf.org/html/rfc2184">rfc2184</link>
          (later updated by <link xlink:href="https://tools.ietf.org/html/rfc2231">rfc2231</link>) was
          published which specified an encoding mechanism to use for encoding them. Since there was a window
          in time where the MIME specifications did not define a way to encode them, some mail client
          developers decided to use the mechanism described by
          <link xlink:href="https://tools.ietf.org/html/rfc2047">rfc2047</link> which was meant for encoding
          non-ASCII text in headers. While this may at first seem logical, the problem with this approach
          was that rfc2047 encoded-word tokens are not allowed to be in quotes (as well as some other issues)
          and so another, more appropriate, encoding mechanism was needed.
        </para>
        <para>
          Outlook is one of those mail clients which decided to encode filenames using the mechanism described
          in rfc2047 and until Outlook 2007, did not support filenames encoded using mechanism defined in
          rfc2231.
        </para>
        <para>
          As of MimeKit v1.2.18, it is possible to configure MimeKit to use the rfc2047 encoding mechanism for
          filenames in the following two ways:
        </para>
        <para>
          The first way is to set the encoding method on each individual
          <codeEntityReference>T:MimeKit.Parameter</codeEntityReference>:
        </para>
        <code language="c#">
Parameter param;

if (attachment.ContentDisposition.Parameters.TryGetValue ("filename", out param))
    param.EncodingMethod = ParameterEncodingMethod.Rfc2047;
        </code>
        <para>
          The other way is to use a <codeEntityReference>T:MimeKit.FormatOptions</codeEntityReference>:
        </para>
        <code language="c#">
var options = FormatOptions.Default.Clone ();
options.ParameterEncodingMethod = ParameterEncodingMethod.Rfc2047;

message.WriteTo (options, stream);
        </code>
      </content>
    </section>

    <section address="DecryptInlinePGP">
      <title>How do I decrypt PGP messages that are embedded in the main message text?</title>
      <content>
        <para>
          Some PGP-enabled mail clients, such as <application>Thunderbird</application>, embed
          encrypted PGP blurbs within the <literal>text/plain</literal> body of the message
          rather than using the PGP/MIME format that MimeKit prefers.
        </para>
        <para>
          These messages often look something like this:
        </para>
        <code language="none" source="Examples\InlinePGPExample.txt"/>
        <para>
          To deal with these kinds of messages, MimeKit's
          <codeEntityReference>T:MimeKit.Cryptography.OpenPgpContext</codeEntityReference>
          includes a
          <codeEntityReference>
            Overload:MimeKit.Cryptography.OpenPgpContext.GetDecryptedStream
          </codeEntityReference>
          method which can be used to get the raw decrypted stream.
        </para>
        <para>
          The method variant that has a
          <codeEntityReference>T:MimeKit.Cryptography.DigitalSignatureCollection</codeEntityReference>
          output parameter is useful in cases where the encrypted PGP blurb is also digitally signed,
          allowing you to get your hands on the list of digitial signatures in order for you to verify
          each of them.
        </para>
        <para>
          To decrypt the sample message above, you could use the following code snippet:
        </para>
        <code language="c#" source="Examples\OpenPGPExamples.cs" region="DecryptInlinePGP"/>
      </content>
    </section>

    <section address="ParseWebRequestFormData">
      <title>How would I parse multipart/form-data from an HTTP web request?</title>
      <content>
        <para>
          Since classes like <codeEntityReference>T:System.Net.HttpWebRequest</codeEntityReference>
          take care of parsing the HTTP headers (which includes the <literal>Content-Type</literal> header)
          and only offer a content stream to consume, MimeKit provides a way to deal with this using the
          following two static methods on <codeEntityReference>T:MimeKit.MimeEntity</codeEntityReference>:
          <codeEntityReference>
            M:MimeKit.MimeEntity.Load(MimeKit.ParserOptions,MimeKit.ContentType,System.IO.Stream,System.Threading.CancellationToken)
          </codeEntityReference>
          and
          <codeEntityReference>
            M:MimeKit.MimeEntity.Load(MimeKit.ContentType,System.IO.Stream,System.Threading.CancellationToken)
          </codeEntityReference>
        </para>
        <para>
          Here's how you might use these methods:
        </para>
        <code language="c#" source="Examples\MultipartFormDataExamples.cs" region="ParseMultipartFormDataSimple"/>
        <para>
          If the multipart/form-data HTTP response is expected to be large and you do
          not wish for the content to be read into memory, you can use the following
          approach:
        </para>
        <code language="c#" source="Examples\MultipartFormDataExamples.cs" region="ParseMultipartFormDataComplex"/>
      </content>
    </section>

    <relatedTopics>
      <link xlink:href="WorkingWithMessages"/>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
